.. _uart_android-label:

8.2 串口协议Android实现参考
---------------------------

根据\ :ref:`通信协议和通信格式 <uart_protocal-label>`\ ，在Android平台进行了实现以供开发参考。
如果上位机平台是Android平台，可以直接集成使用。

Android SDK的接口设计同\ :ref:`AIUI SDK理解 <AIUI_SDK_deep-label>`\ 类似，通过串口架起与AIUIService交互的桥梁，
通过收发AIUI消息，获取AIUI结果和控制AIUI的运行。


8.2.1 权限
^^^^^^^^^^

**请确保应用有读写对应串口设备的权限（即对/dev/下的串口设备文件有rw权限）。**

8.2.2 调用流程
^^^^^^^^^^^^^^

调用主要接口类是UARTAgent。

在程序首次初始化的地方调用静态方法createAgent创建UARTAgent实例，传入EventListener参数用于接收串口事件，
后面调用创建的UARTAget实例的sendMessage方法发送串口消息，在程序结束前调用UARTAgent实例的destroy方法释放资源。

8.2.3 接口说明
^^^^^^^^^^^^^^

* 创建UARTAgent::

     UARTAgent createAgent(String device, int speed, EventListener listener)

  * device 串口设备名（如/dev/ttyS2）
  
  * speed 串口速率 (串口速率一般为115200)
  
  * listener 串口事件监听器

* 发送串口消息::

     boolean sendMessage(MsgPacket reqPacket)

  * reqPacket 串口数据包

* 销毁串口，释放资源::

     void destroy()
     
8.2.4 串口数据包
^^^^^^^^^^^^^^^^

实现根据通信数据格式对串口数据类型进行了封装，MsgPacket是所有类型串口数据包的父类。

实现包装的串口数据类型如下：

* AIUIPacket AIUI消息

* AIUIConfPacket AIUI配置

* ControlPacket 主控消息

* WIFIConfPacket WIFI配置

*注：各个类型中字段的定义参见附录*

实现中在PacketBuilder类中提供了静态方法构造上面列举的数据包：

* 构造AIUI配置请求数据包::

     MsgPacket obtainAIUIConfPacket(String appid, String key, String sence, boolean launchDemo)

* 构造保存音频请求数据包::

     MsgPacket obtainAIUIAudioRecordCmdPacket()

* 构造获取WIFI状态请求数据包::

     MsgPacket obtainWIFIStatusReqPacket()

* 构造声音控制请求数据包::

     MsgPacket obtainVoiceCtrPacket(boolean enable)

* 构造AIUI控制请求数据包::

     MsgPacket obtainAIUICtrPacket(int msgType, int arg1, int arg2, String params)

* 构造WIFI配置结果数据包::

     MsgPacket obtainWIFIConfPacket(WIFIStatus status, EncryptMethod type, String ssid, String passwd)

8.2.5 串口事件监听器
^^^^^^^^^^^^^^^^^^^^

在上面创建UARTAgent实例中，传入的EventListener类型的参数listener用于监听接收串口事件。

EventListener的类型定义如下::

    interface EventListener {
        void onEvent(UARTEvent event);
    }
     
接口方法onEvent中UARTEvent即为串口事件，定义如下::

    class UARTEvent {
        int eventType; //串口事件类型
        Object data;   //串口事件数据
    }
     
在eventType取不同的事件类型是，串口事件数据也有不同的数据类型。

定义的串口事件类型和对应事件数据如下：

+-------------+---------------------+------------+------------------+
|事件说明     | 事件类型            | 数据类型   | 数据说明         |
+-------------+---------------------+------------+------------------+
|初始化成功   | EVENT_INIT_SUCCESS  | 无         | 无               |
+-------------+---------------------+------------+------------------+
|初始化失败   | EVENT_INIT_FAILED   | 无         | 无               |
+-------------+---------------------+------------+------------------+
|串口消息     | EVENT_MSG           | MsgPacket  | 接收到的数据包   |
+-------------+---------------------+------------+------------------+
|消息发送失败 | EVENT_SEND_FAILED   | MsgPacket  | 发送失败的数据包 |
+-------------+---------------------+------------+------------------+

具体事件处理参见\ :ref:`代码示例 <uart_android_code-label>`\ 。

.. _uart_android_code-label:

8.2.6 代码示例
^^^^^^^^^^^^^^^

下面代码示例了上位机集成使用的通用流程::

	mAgent = UARTAgent.createAgent("/dev/ttyS2", 115200, new EventListener() {

		@Override
		public void onEvent(UARTEvent event) {
			switch (event.eventType) {
				case UARTConstant.EVENT_INIT_SUCCESS:              //处理初始化成功事件
					Log.d(TAG, "Init UART Success");
					break;

				case UARTConstant.EVENT_INIT_FAILED:               //处理初始化失败事件
					Log.d(TAG, "Init UART Failed");
					break;

				case UARTConstant.EVENT_MSG:                       //消息回调事件
					MsgPacket recvPacket = (MsgPacket) event.data;
					processPacket(recvPacket);
					break;

				case UARTConstant.EVENT_SEND_FAILED:               //消息发送失败事件
					MsgPacket sendPacket = (MsgPacket) event.data;
					mAgent.sendMessage(sendPacket);
					break;
				default:
					break;
			}
		}
	});

	//消息处理
	private void processPacket(MsgPacket packet) {
		switch (packet.getMsgType()) {
			case MsgPacket.AIUI_PACKET_TYPE:
				Log.d(TAG, "recv aiui result" + new String(((AIUIPacket) packet).content));
				break;
			default:
				break;
		}
	}

	//发送AIUI配置信息
	if(intent.hasExtra("aiui_conf")){
		mAgent.sendMessage(PacketBuilder.obtainAIUIConfPacket("appid", "key", "main", false));
    }
	
8.2.7 附录
^^^^^^^^^^

所有串口数据包的父类都是MsgPacket，方法getMsgType()返回数据包类型。

MsgPacket中定义的数据包类型如下：

* MsgPacket.WIFI_CONF_TYPE

* MsgPacket.AIUI_CONF_TYPE

* MsgPacket.AIUI_PACKET_TYPE

* MsgPacket.CTR_PACKET_TYPE

各个数据包类型成员定义：

* AIUI消息::

	class AIUIPacket {
	  String content           //AIUI语音识别数据
	}
	
* AIUI配置::

	class AIUIConfPacket {
	  String config           //AIUI配置信息
	}
  
* WIFI配置::

	class WIFIConfPacket {
	  WIFIStatus status;       //WIFI连接状态
	  EncryptMethod encrypt;   //WIFI加密方式
	  String ssid;             //WIFI名称
	  String passwd;           //WIFI密码
	} 
  
* 主控消息::

	class ControlPacket {
	  String controlCMD        //主控控制消息
	} 